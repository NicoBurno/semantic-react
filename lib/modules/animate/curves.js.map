{"version":3,"sources":["../../../src/components/modules/animate/curves.js"],"names":[],"mappings":"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","file":"curves.js","sourcesContent":["/*eslint-disable */\r\n/* Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License:\r\n http://en.wikipedia.org/wiki/MIT_License */\r\nexports.bezier = function(mX1, mY1, mX2, mY2) {\r\n    var NEWTON_ITERATIONS = 4,\r\n        NEWTON_MIN_SLOPE = 0.001,\r\n        SUBDIVISION_PRECISION = 0.0000001,\r\n        SUBDIVISION_MAX_ITERATIONS = 10,\r\n        kSplineTableSize = 11,\r\n        kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),\r\n        float32ArraySupported = \"Float32Array\" in window;\r\n\r\n    /* Must contain four arguments. */\r\n    if (arguments.length !== 4) {\r\n        return false;\r\n    }\r\n\r\n    /* Arguments must be numbers. */\r\n    for (var i = 0; i < 4; ++i) {\r\n        if (typeof arguments[i] !== \"number\" || isNaN(arguments[i]) || !isFinite(arguments[i])) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /* X values must be in the [0, 1] range. */\r\n    mX1 = Math.min(mX1, 1);\r\n    mX2 = Math.min(mX2, 1);\r\n    mX1 = Math.max(mX1, 0);\r\n    mX2 = Math.max(mX2, 0);\r\n\r\n    var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\r\n\r\n    function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }\r\n    function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }\r\n    function C (aA1)      { return 3.0 * aA1; }\r\n\r\n    function calcBezier (aT, aA1, aA2) {\r\n        return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;\r\n    }\r\n\r\n    function getSlope (aT, aA1, aA2) {\r\n        return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\r\n    }\r\n\r\n    function newtonRaphsonIterate (aX, aGuessT) {\r\n        for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\r\n            var currentSlope = getSlope(aGuessT, mX1, mX2);\r\n\r\n            if (currentSlope === 0.0) return aGuessT;\r\n\r\n            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\r\n            aGuessT -= currentX / currentSlope;\r\n        }\r\n\r\n        return aGuessT;\r\n    }\r\n\r\n    function calcSampleValues () {\r\n        for (var i = 0; i < kSplineTableSize; ++i) {\r\n            mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\r\n        }\r\n    }\r\n\r\n    function binarySubdivide (aX, aA, aB) {\r\n        var currentX, currentT, i = 0;\r\n\r\n        do {\r\n            currentT = aA + (aB - aA) / 2.0;\r\n            currentX = calcBezier(currentT, mX1, mX2) - aX;\r\n            if (currentX > 0.0) {\r\n                aB = currentT;\r\n            } else {\r\n                aA = currentT;\r\n            }\r\n        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\r\n\r\n        return currentT;\r\n    }\r\n\r\n    function getTForX (aX) {\r\n        var intervalStart = 0.0,\r\n            currentSample = 1,\r\n            lastSample = kSplineTableSize - 1;\r\n\r\n        for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {\r\n            intervalStart += kSampleStepSize;\r\n        }\r\n\r\n        --currentSample;\r\n\r\n        var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]),\r\n            guessForT = intervalStart + dist * kSampleStepSize,\r\n            initialSlope = getSlope(guessForT, mX1, mX2);\r\n\r\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\r\n            return newtonRaphsonIterate(aX, guessForT);\r\n        } else if (initialSlope === 0.0) {\r\n            return guessForT;\r\n        } else {\r\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);\r\n        }\r\n    }\r\n\r\n    var _precomputed = false;\r\n\r\n    function precompute() {\r\n        _precomputed = true;\r\n        if (mX1 !== mY1 || mX2 !== mY2) calcSampleValues();\r\n    }\r\n\r\n    var f = function (aX) {\r\n        if (!_precomputed) precompute();\r\n        if (mX1 === mY1 && mX2 === mY2) return aX;\r\n        if (aX === 0) return 0;\r\n        if (aX === 1) return 1;\r\n\r\n        return calcBezier(getTForX(aX), mY1, mY2);\r\n    };\r\n\r\n    f.getControlPoints = function() { return [{ x: mX1, y: mY1 }, { x: mX2, y: mY2 }]; };\r\n\r\n    var str = \"generateBezier(\" + [mX1, mY1, mX2, mY2] + \")\";\r\n    f.toString = function () { return str; };\r\n\r\n    return f;\r\n};\r\n\r\n\r\n/* Runge-Kutta spring physics function generator. Adapted from Framer.js,\r\n copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */\r\n/* Given a tension, friction, and duration, a simulation at 60FPS will first run\r\n without a defined duration in order to calculate the full path. A second pass\r\n then adjusts the time delta -- using the relation between actual time and\r\n duration -- to calculate the path for the duration-constrained animation. */\r\nexports.spring = (function () {\r\n    function springAccelerationForState (state) {\r\n        return (-state.tension * state.x) - (state.friction * state.v);\r\n    }\r\n\r\n    function springEvaluateStateWithDerivative (initialState, dt, derivative) {\r\n        var state = {\r\n            x: initialState.x + derivative.dx * dt,\r\n            v: initialState.v + derivative.dv * dt,\r\n            tension: initialState.tension,\r\n            friction: initialState.friction\r\n        };\r\n\r\n        return { dx: state.v, dv: springAccelerationForState(state) };\r\n    }\r\n\r\n    function springIntegrateState (state, dt) {\r\n        var a = {\r\n                dx: state.v,\r\n                dv: springAccelerationForState(state)\r\n            },\r\n            b = springEvaluateStateWithDerivative(state, dt * 0.5, a),\r\n            c = springEvaluateStateWithDerivative(state, dt * 0.5, b),\r\n            d = springEvaluateStateWithDerivative(state, dt, c),\r\n            dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),\r\n            dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);\r\n\r\n        state.x = state.x + dxdt * dt;\r\n        state.v = state.v + dvdt * dt;\r\n\r\n        return state;\r\n    }\r\n\r\n    return function springRK4Factory (tension, friction, duration) {\r\n\r\n        var initState = {\r\n                x: -1,\r\n                v: 0,\r\n                tension: null,\r\n                friction: null\r\n            },\r\n            path = [0],\r\n            time_lapsed = 0,\r\n            tolerance = 1 / 10000,\r\n            DT = 16 / 1000,\r\n            have_duration, dt, last_state;\r\n\r\n        tension = parseFloat(tension) || 500;\r\n        friction = parseFloat(friction) || 20;\r\n        duration = duration || null;\r\n\r\n        initState.tension = tension;\r\n        initState.friction = friction;\r\n\r\n        have_duration = duration !== null;\r\n\r\n        /* Calculate the actual time it takes for this animation to complete with the provided conditions. */\r\n        if (have_duration) {\r\n            /* Run the simulation without a duration. */\r\n            time_lapsed = springRK4Factory(tension, friction);\r\n            /* Compute the adjusted time delta. */\r\n            dt = time_lapsed / duration * DT;\r\n        } else {\r\n            dt = DT;\r\n        }\r\n\r\n        while (true) {\r\n            /* Next/step function .*/\r\n            last_state = springIntegrateState(last_state || initState, dt);\r\n            /* Store the position. */\r\n            path.push(1 + last_state.x);\r\n            time_lapsed += 16;\r\n            /* If the change threshold is reached, break. */\r\n            if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        /* If duration is not defined, return the actual time required for\r\n         completing this animation. Otherwise, return a closure that holds\r\n         the computed path and returns a snapshot of the position according to\r\n         a given percentComplete. */\r\n        return !have_duration ? time_lapsed : function(percentComplete) {\r\n            return path[ (percentComplete * (path.length - 1)) | 0 ];\r\n        };\r\n    };\r\n}());\r\n/*eslint-enable */"]}